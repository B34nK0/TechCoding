/*
c++11 特性有哪些

1、左值与右值
左值是指表达式结束后依然存在的持久对象
右值是指表达式结束时就不再存在的临时对象

2、通过右值方式得到函数里的变量
a、函数返回的临时对象是右值，可以通过右值引用（T &&）的方式来延长临时右值的生命周期
A GetA() {
	return A();
}

A&& a = GetA();
、
b、通过常量左值引用（接受左值、右值、常量左值和常量右值），必须是常量左值引用
const A& a = GetA();


3、move之后对象在哪里
moove方法将对象的状态或者所有权从给一个对象转移到另一个对象，只是转移，并没有内存拷贝，可理解为将一个左值强制转换为一个右值引用

move跟forward
forward要解决的是在函数模板中，完全按照模板的参数的类型（保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。

4、unique_ptr 与 auto_ptr的区别
unique_ptr是独占型只能指针，不允许其他的智能指针共享其内部的指针，不允许赋值，但支持move转移所有权
虽然同一时间只有一个auto_ptr拥有对象的指针，但其允许复制，会导致另一个auto_ptr指向空指针，造成指针访问异常

5、shared_ptr的实现机制
使用引用计数，每一个shared_ptr拷贝都指向相同的内存，最后一个shared_ptr析构时，内存才会释放

6、shared_ptr循环引用
把循环引用的任何一个成员变量改为weak_ptr

7、虚函数表相关信息
派生类在编译时，会生成一个虚函数表指针和虚函数表，虚函数表记录派生类重载的函数实现地址

内存布局的哪个区
对象指针 A* obj存放在栈上， 指针指向堆上的实例A内存，A实例内存里包含了虚表指针，指针指向只读数据段上的虚函数表，虚函数表记录的是派生类重载实现的函数指针，函数指针指向代码段上的虚函数代码

A重写B类的虚函数，内存有什么变化
A实例内存有虚表指针

8、进程跟线程之间的区别
进程是资源分配的最小单位、线程是CPU调度的最小单位
一个线程只能属于一个进程，一个进程可以有多个线程
进程在执行过程中拥有独立内存单元，而多个线程共享所属进程的内存。
（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。
但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
进程的系统开销（创建、撤销、调度执行）比线程大
进程内的线程具有相同的内存地址，线程间通信简单
进程间独立不影响，线程异常会导致进程异常，进而影响其他线程
进程适用于多核、多机， 线程适用于多核

9、什么场景下使用进程、线程
cpu密集型时使用进程，可以独占cpu进行计算任务
io密集型时可以使用线程

10、进程间通信方式
管道
	命名管道、匿名管道


系统IPC（信号量、信号、消息队列、共享内存）
信号量：主要用于进程同步，多用于配合共享内存，实现进程通信

信号：用于通知接收进程某个事件已经发生

消息队列：是消息的链接表，存放在内核中

共享内存：多个进程操作同一内存，最快的IPC方式，需要采用信号量同步多进程对共享内存的操作

套接字Socket
用于不同主机间通信


11、线程间通信方式
线程间通信主要目的在于线程同步，并不是进行数据交换（数据交互更多体现在临界资源的操作）

锁机制:互斥锁(mutex)、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）

信号量机制

信号

屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

12、epoll跟IOCP的区别
Epoll 是当事件资源满足时发出可处理通知消息；而 IOCP 则是当事件完成时发出完成通知消息。
epoll是同步非阻塞、iocp是异步非阻塞

13、阻塞\非阻塞,同步\异步分别是在哪些阶段
阻塞\非阻塞主要用于创建IO句柄后，用户是阻塞等待等待数据，还是非阻塞去做其他事情，IO有数据时再通知用户进行读取
异步\同步在于读取数据的动作，同步指读取数据时缓冲区数据没有读取完时一直读取，还是用户去做其他事情，等待全部数据读取完再通知用户读取


14、epoll用到的是水平触发还是边缘触发
et边缘触发：et模式，是当发生事件时进行一次通知，epool_wait获取该次事件后，如果用户不处理完缓冲区数据，使用epoll_wait是不会再获取到事件
所以必须使用非阻塞io，如果使用阻塞io，那么不处理完数据时，阻塞读写会把处理多个文件描述符的任务饿死

lt水平触发：当一个文件句柄准备就绪时，内核会通知用户进行io操作，如果不进行任何操作时，内核还是会继续通知用户关于该句柄的事件

15、水平触发跟边缘触发的优缺点
epoll默认时水平触发，其优点是如果io有数据，会一直通知，保证了数据的完整输出
缺点是只要一有数据，内核就会不断的通知，进行内核态到用户态的切换，占用了大量的内核资源

边缘触发的优点是每次内核只通知一次，大大减少了内核资源的浪费，提高效率
缺点是，不能保证数据的完整性，不能及时取出所有的数据

场景：使用边缘触发时，如果有读事件时，没有把数据读取完，在socket没有新的数据可读时，epoll就不返回了，那需要等到新的数据来时，epoll返回可读事件时才能继续读
使用水平触发时，如果关注写事件时，多次写时都会有epoll的返回，那么会造成内核资源的浪费，一般也不关注写事件

16、accept，socket处于什么状态，在半链接队列还是全链接队列里
a、在三次握手过程中，客户端发送SYN包到服务端，服务端会在半链接队列创建一个条目进行记录，之后返回ack给客户端，此时服务端处于syn_recv状态
b、客户端收到syn+ack后，任何与服务端建立了链接，此时处于established状态，并返回ack给到服务端
c、服务端收到ack后任何已经确认链接了，会将半链接状态的条目删除后，在全链接队列新建条目，此时状态处于established
d、服务端应用进程调用accept函数，将连接从全连接队列(Accept Queue)中取出


17、环形缓冲区
采用收尾相接的固定容量数组来实现队列，如果容量需要动态变化的话可以采用链表的方式
原理：
采用读指针、写指针，读写指针用整型表示
采用1个空位置来区分读写指针位置，当前数据长度 = 写位置-读位置，如果数据长度==1，说明当前队列为空，当写指针+1 = 读指针时，表明队列已满
也可以采用数据量来区分队列是空还是满


18、cas( Compare And Swap)
是一种无锁原子算法，映射到操作系统就是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，
其实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。

cpu在执行任务的时候并不是直接从内存中加载数据，而是会先将数据加载到L1和L2 cache中（典型的是两层缓存，甚至可能更多），然后再从cache中读取数据进行运算。
而现在的计算机通常都是多核处理器，每一个内核都对应一个独立的L1层缓存，多核之间的缓存数据同步是cpu框架设计的重要部分，MESI是比较常用的多核缓存同步方案。

cpu采用两种锁机制
总线锁bus lock，使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。

缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而是修改内部的内存地址，
并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），
当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。
如果不是在处理器的缓存行中，还是得使用总线锁

19、cas aba问题
多线程情况下，1线程比较原值为A时，可能其他线程对值进行无数操作之后又变回了A值，即中间其实发生过A-》B-》A的状态改变，而此时1线程认为A值是期望值，所以进行新值交换。
可通过对值进行版本号判断来解决，虽然当前是A值，但已经经过了多个版本变化了

20、内存模型
关于c++的内存模型，分为三种： relaxed ordering(松弛次序)、acquire-release ordering（获取-释放次序）、sequentially consistent ordering（顺序一致次序），
C++11 提供了6种操作（memory_order_relaxed， memory_order_consume， memory_order_acquire， memory_order_reelase， memory_order_acq_rel， memory_order_seq_cst）

*/
/*
mysql

分表

分库分表的方案

聚簇索引跟非聚簇索引的实现


*/

/*
redis 使用了哪些数据类型及场景

redis是独立数据，还是mysql的缓存

redis如何做到数据一致性，mysql更新完成程序崩溃

redis淘汰策略
*/

/*
service mesh

注册中心机制

远程调用，服务不可用

服务不可用是否实现高可用（负载转发）

负载均衡策略有哪些


*/

/*
c++ 运行期如何识别结构体的成员变量类型
*/
